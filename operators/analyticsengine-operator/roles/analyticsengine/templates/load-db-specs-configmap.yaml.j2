apiVersion: v1
kind: ConfigMap
metadata:
  name: "{{ name }}-load-db-specs-script"
  labels:
    function: "{{ name }}-load-db-specs"
{% if cpdLabels  %} 
    {{ cpdLabels | to_nice_yaml| indent(4) }}
{% endif %}
data:
  load-db-specs.sh: |-
    #!/bin/bash
    
    script_path=$1
    docker_repo=$2
    version=$3
    zen_metastore_certs_path=$4
    temp_zen_metastore_path=$5
    
    exec_cmd()
    {
        CMD=$1
        eval $CMD
        if [ $? -ne 0 ]
        then
            echo "Error : failed to execute the command: $CMD"
            exit 1
        fi
    }
    
    exec_cmd "mkdir -p $zen_metastore_certs_path"
    exec_cmd "cp -r $temp_zen_metastore_path/..data/* $zen_metastore_certs_path"
    exec_cmd "chmod 600 $zen_metastore_certs_path/*"
    
    #------------------------------------
    # Configure cockroach DB
    #------------------------------------
    echo "connecting to cockroach db $DB_URL"
    echo "Invoking script load_db.py"
    python $script_path/load_db.py $DB_URL $script_path/create_tables.sql $version
    echo "Executed script load_db.py"
{% if spark_metastoredb.cockroachdb %}
  load_db.py: |-
    import psycopg2
    import sys
    
    def closeConnection(cursor, connection):
        cursor.close()
        connection.commit()
        connection.close()
        print("Cockroach DB connection is closed")
    
    def upgrade_sql(version):
        switcher={
            0:'',
            1:'ALTER TABLE INSTANCE_MANAGER ADD COLUMN cpu_quota INT, ADD COLUMN memory_quota TEXT, ADD COLUMN avail_cpu_quota INT, ADD COLUMN avail_memory_quota TEXT; ALTER TABLE JOB ADD COLUMN resources_updated BOOLEAN;',
            2:'ALTER TABLE INSTANCE_MANAGER ADD COLUMN context_type TEXT, ADD COLUMN context_id TEXT, ADD COLUMN spark_confs jsonb;',
            3:'ALTER TABLE DATAPLANE_MANAGER ADD COLUMN additional_details jsonb;',
            4:'ALTER TABLE DEPLOY_REQUEST ADD COLUMN runtime_id TEXT;',
            5:'ALTER TABLE DEPLOYMENT ADD COLUMN deployer_type TEXT; ALTER TABLE INSTANCE_MANAGER ADD COLUMN job_def_id VARCHAR (512); ALTER TABLE JOB ADD COLUMN context_type TEXT, ADD COLUMN context_id TEXT, ADD COLUMN job_def_id TEXT, ADD COLUMN job_run_id TEXT; ALTER TABLE SERVICE_PROVIDER ADD COLUMN space_id STRING, ADD COLUMN job_def_id STRING;',
        	6:'ALTER TABLE SERVICE_PROVIDER ADD COLUMN CUSTOMISATION_DEPLOYMENT_REQUEST_ID VARCHAR(256);'
        }
        return switcher.get(version)
    
    def checkIfUpgrade(url, version):
        try:
           #print ("About to make a connection")
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           sql="set database=spark;show tables;"
           cursor.execute(sql)
           row_count = cursor.rowcount
           row = cursor.fetchall()
           if row_count != 0 and ("db_version",) not in row:
               print("db_version table not present")
               current_version=0
           elif row_count != 0 and ("db_version",) in row:
               print("db_version table present")
               cursor.execute("SELECT * from DB_VERSION")
               current_version=cursor.fetchone()[0]
           else:
               current_version=version
        except (Exception, psycopg2.Error) as error :
            print ("Error while connecting to Cockroach DB", error)
            raise Exception('Error executing sql')
            exit(1)
        finally:
            if(connection):
                closeConnection(cursor, connection)
            return current_version
    
    def load_db(url, sql_file):
        try:
           #print ("About to make a connection")
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           cursor.execute(open(sql_file, "r").read())
           print (" sql execution completed")
        except (Exception, psycopg2.Error) as error :
            print ("Error while connecting to Cockroach DB", error)
            raise Exception('Error executing sql')
            exit(1)
        finally:
            if(connection):
                closeConnection(cursor, connection)
    
    
    def upgrade(url,current_version, version):
        try:
           #print ("About to make a connection")
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           rows = cursor.execute("SELECT * from DB_VERSION")
           row_count = cursor.rowcount
           if row_count == 0:
               print("Version table is empty")
               sql="INSERT into DB_VERSION VALUES(%d)" % (current_version)
               cursor.execute(sql)
               print (" sql execution completed")
           else:
               print("Version table not empty, take current version from table.")
               current_version=cursor.fetchone()[0]
               print(current_version)
    
           closeConnection(cursor, connection)
    
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           if current_version<version:
               print("upgrade here")
               for x in range(current_version+1, version+1):
                   cursor.execute(upgrade_sql(x))
               sql="UPDATE DB_VERSION SET version=(%d)" % (version)
               cursor.execute(sql)
           else:
               print("do not upgrade")
        except (Exception, psycopg2.Error) as error :
            print ("Error while connecting to Cockroach DB", error)
            raise Exception('Error executing sql')
            exit(1)
        finally:
            if(connection):
                closeConnection(cursor, connection)
    
    
    if __name__ == "__main__":
        if len (sys.argv) < 4 :
            print("Error : missing one or more arguments")
            print("Usage : python {0} <db_url> <sql_filename> <db_version>".format(sys.argv[0]))
            exit(1)
        else:
            db_url = sys.argv[1]
            sql_file = sys.argv[2]
            version = int(sys.argv[3])
        try:
            current_version=checkIfUpgrade(db_url,version)
            load_db(db_url, sql_file)
            upgrade(db_url, current_version, version)
            exit(0)
        except Exception as err:
            sys.stderr.write('ERROR: %sn' % str(err))
            exit(1)
  create_tables.sql: |-
    SET DATABASE=SPARK;
    
    CREATE TABLE IF NOT EXISTS DB_VERSION (version INT PRIMARY KEY NOT NULL);
    
    CREATE TABLE  IF NOT EXISTS SERVICE_PROVIDER  (id STRING PRIMARY KEY NOT NULL, instance_id STRING NOT NULL, api_key STRING, state TEXT, metadata jsonb, parameters jsonb,
    serviceInstanceDescription STRING, serviceInstanceDisplayName STRING, serviceInstanceNamespace STRING, transientFields jsonb, zenServiceInstanceInfo jsonb, space_id STRING, job_def_id STRING, creation_date STRING, updation_date STRING, document_type STRING, CUSTOMISATION_DEPLOYMENT_REQUEST_ID VARCHAR(256));
    
    CREATE TABLE  IF NOT EXISTS HB_USERS  (id SERIAL PRIMARY KEY NOT NULL, uid STRING NOT NULL, sID STRING NOT NULL, role STRING, username STRING, password STRING,
    state STRING, creation_date STRING, updation_date STRING);
    
    CREATE TABLE  IF NOT EXISTS INSTANCE_MANAGER  (
        id SERIAL NOT NULL,
        instance_id TEXT PRIMARY KEY NOT NULL,
        home_volume jsonb,
        api_key TEXT,
        state TEXT,
        account_id TEXT,
        project_id  TEXT,
        creation_date TEXT,
        updation_date TEXT,
        document_type TEXT,
        namespace TEXT,
        deployment_request_id TEXT,
        dataplane_url TEXT,
        cpu_quota INT,
        memory_quota TEXT,
        avail_cpu_quota INT,
        avail_memory_quota TEXT,
        context_type TEXT,
        context_id TEXT,
        job_def_id VARCHAR (512),
        spark_confs jsonb);
    
    CREATE TABLE IF NOT EXISTS dataplane_manager (id STRING PRIMARY KEY NOT NULL, external_dataplane_url STRING, internal_dataplane_url STRING, state STRING, creation_date TIMESTAMP,
    updation_date TIMESTAMP, document_type STRING, msg STRING, tag STRING, name STRING, project_id STRING, nfs jsonb, available_pod_resources jsonb, additional_details jsonb);
    
    CREATE TABLE  IF NOT EXISTS DEPLOY_REQUEST(id STRING PRIMARY KEY NOT NULL,runtime_id STRING,state STRING,document_type STRING,creation_date TIMESTAMP,updation_date TIMESTAMP, data_plane_uri STRING,
    deployment_details jsonb);
    
    CREATE TABLE  IF NOT EXISTS DEPLOYMENT(id STRING PRIMARY KEY NOT NULL, uu_id STRING, state STRING,document_type STRING,creation_date TIMESTAMP,updation_date TIMESTAMP,
    deployment_details jsonb, deployer_type STRING, deployment_blueprint jsonb, deployment_type STRING);
    
    CREATE TABLE  IF NOT EXISTS JOB  (
        id SERIAL NOT NULL,
        job_id TEXT PRIMARY KEY NOT NULL,
        instance_id TEXT NOT NULL,
        version TEXT,
        eng jsonb,
        app_args jsonb,
        app_resource TEXT,
        main_class TEXT,
        dataplane_uri TEXT,
        external_dataplane_uri TEXT,
        nfs_home_volume jsonb,
        driver_id TEXT,
        environment TEXT,
        job_state TEXT,
        start_time TIMESTAMP,
        finish_time TIMESTAMP,
        killed_time TIMESTAMP,
        failed_time TIMESTAMP,
        environment_name TEXT,
        runtime_registration_params jsonb,
        register_job_enabled BOOLEAN,
        return_code TEXT,
        mode TEXT,
        user_log_dir TEXT,
        document_type TEXT,
        state TEXT,
        creation_date TIMESTAMP,
        updation_date TIMESTAMP,
        deployment_request_id TEXT,
        project_id TEXT,
        pvc_name TEXT,
        spark_app_id TEXT,
        user_name TEXT,
        resources_updated BOOLEAN,
        context_type TEXT,
        context_id TEXT,
        job_def_id TEXT,
        job_run_id TEXT
        );
    
    CREATE TABLE  IF NOT EXISTS KERNEL (id SERIAL NOT NULL, kernel_id STRING PRIMARY KEY NOT NULL, instance_id STRING NOT NULL, name STRING, external_dataplane_uri STRING,
    usr_lib_cos jsonb, eng jsonb, jkg_size jsonb, register_kernel_enabled BOOLEAN, env jsonb, nfs_home_volume jsonb, environment STRING, environment_name STRING,
    runtime_registration_params jsonb, decommission_time TIMESTAMP, commission_time TIMESTAMP, deletion_time TIMESTAMP, deployment_time TIMESTAMP, document_type STRING,
    state STRING, creation_date TIMESTAMP, updation_date TIMESTAMP, cleanup_deployment_request_id STRING, deployment_request_id  STRING);
    
    CREATE TABLE IF NOT EXISTS INSTANCE(
         id VARCHAR(36) PRIMARY KEY NOT NULL,
         home_volume VARCHAR (256),
         template_id VARCHAR (256),
         configs TEXT,
         cpu_quota INT,
         memory_quota INT,
         avail_cpu_quota INT,
         avail_memory_quota INT,
         state VARCHAR (32),
         creation_time TIMESTAMPTZ,
         state_change_time TIMESTAMPTZ,
         namespace VARCHAR (32),
         history_server_deployment_request_id VARCHAR (128),
         context_type VARCHAR (32),
         context_id VARCHAR (512),
         job_def_id VARCHAR (512),
         dataplane_type VARCHAR (512),
         dataplane_url VARCHAR (512)
     );
    
      CREATE TABLE IF NOT EXISTS VOLUME_MOUNT (
         id VARCHAR (36) PRIMARY KEY NOT NULL,
         instance_id VARCHAR (36) REFERENCES INSTANCE (id),
         name VARCHAR (256),
         source_sub_path VARCHAR (512),
         mount_path VARCHAR (512)
     );
    
      CREATE TABLE IF NOT EXISTS VOLUME_DEFINITION (
         instance_id VARCHAR(36) REFERENCES INSTANCE (id),
         name VARCHAR (256),
         provider VARCHAR(64),
         type VARCHAR(64),
         details TEXT,
         PRIMARY KEY(instance_id, name)
     );
    
      CREATE TABLE IF NOT EXISTS APPLICATION (
        type VARCHAR(32),
        application_id VARCHAR(36) PRIMARY KEY NOT NULL,
        instance_id VARCHAR(36),
        application_details TEXT,
        environment VARCHAR(36),
        state VARCHAR(36),
        start_time TIMESTAMPTZ,
        finish_time TIMESTAMPTZ,
        failed_time TIMESTAMPTZ,
        additional_attributes TEXT,
        return_code VARCHAR(36),
        mode VARCHAR(36)
        );
    
     
      CREATE TABLE IF NOT EXISTS APPLICATION_VOLUME_MAP (
        application_id VARCHAR(36),
        instance_id VARCHAR(36),
        name VARCHAR(256),
        source_sub_path VARCHAR(512),
        mount_path VARCHAR(512),
        mode VARCHAR(36)
        );
    
     
      CREATE TABLE IF NOT EXISTS RUNTIME (
        application_id VARCHAR(36),
        template_id VARCHAR(128),
        master_memory BIGINT,
        master_cores INT,
        worker_memory BIGINT,
        worker_cores INT,
        num_workers_running INT,
        num_workers_requested INT,
        creation_time TIMESTAMPTZ,
        state_change_time TIMESTAMPTZ,
        updation_time TIMESTAMPTZ,
        state VARCHAR(36),
        deployment_request_id VARCHAR(36),
        dataplane_uri VARCHAR(256),
        external_dataplane_uri VARCHAR(256)
        );
    
      CREATE TABLE IF NOT EXISTS APPLICATION_REQUEST_RESPONSE_TRACKER (
        application_id VARCHAR(36),
        instance_id VARCHAR(36),
        request_type VARCHAR(36),
        requested_time TIMESTAMPTZ,
        response_code INT,
        response_message VARCHAR(128)
        );
{% else %}
  load_db.py: |-
    import psycopg2
    import sys
    
    def closeConnection(cursor, connection):
        cursor.close()
        connection.commit()
        connection.close()
        print("Cockroach DB connection is closed")
    
    def upgrade_sql(version):
        switcher={
            0:'',
            1:'ALTER TABLE INSTANCE_MANAGER ADD COLUMN cpu_quota INT, ADD COLUMN memory_quota TEXT, ADD COLUMN avail_cpu_quota INT, ADD COLUMN avail_memory_quota TEXT; ALTER TABLE JOB ADD COLUMN resources_updated BOOLEAN;',
            2:'ALTER TABLE INSTANCE_MANAGER ADD COLUMN context_type TEXT, ADD COLUMN context_id TEXT, ADD COLUMN spark_confs jsonb;',
            3:'ALTER TABLE DATAPLANE_MANAGER ADD COLUMN additional_details jsonb;',
            4:'ALTER TABLE DEPLOY_REQUEST ADD COLUMN runtime_id TEXT;',
            5:'ALTER TABLE DEPLOYMENT ADD COLUMN deployer_type TEXT; ALTER TABLE INSTANCE_MANAGER ADD COLUMN job_def_id VARCHAR (512); ALTER TABLE JOB ADD COLUMN context_type TEXT, ADD COLUMN context_id TEXT, ADD COLUMN job_def_id TEXT, ADD COLUMN job_run_id TEXT; ALTER TABLE SERVICE_PROVIDER ADD COLUMN space_id TEXT, ADD COLUMN job_def_id TEXT;'
        }
        return switcher.get(version)
    
    def checkIfUpgrade(url, version):
        try:
           #print ("About to make a connection")
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           sql="SELECT table_name FROM information_schema.tables WHERE(table_schema = 'public') ORDER BY table_name;"
           cursor.execute(sql)
           row_count = cursor.rowcount
           row = cursor.fetchall()
           if row_count != 0 and ("db_version",) not in row:
               print("db_version table not present")
               current_version=0
           elif row_count != 0 and ("db_version",) in row:
               print("db_version table present")
               cursor.execute("SELECT * from DB_VERSION")
               current_version=cursor.fetchone()[0]
           else:
               current_version=version
        except (Exception, psycopg2.Error) as error :
            print ("Error while connecting to Cockroach DB", error)
            raise Exception('Error executing sql')
            exit(1)
        finally:
            if(connection):
                closeConnection(cursor, connection)
            return current_version
    
    def load_db(url, sql_file):
        try:
           #print ("About to make a connection")
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           cursor.execute(open(sql_file, "r").read())
           print (" sql execution completed")
        except (Exception, psycopg2.Error) as error :
            print ("Error while connecting to Cockroach DB", error)
            raise Exception('Error executing sql')
            exit(1)
        finally:
            if(connection):
                closeConnection(cursor, connection)
    
    
    def upgrade(url,current_version, version):
        try:
           #print ("About to make a connection")
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           rows = cursor.execute("SELECT * from DB_VERSION")
           row_count = cursor.rowcount
           if row_count == 0:
               print("Version table is empty")
               sql="INSERT into DB_VERSION VALUES(%d)" % (current_version)
               cursor.execute(sql)
               print (" sql execution completed")
           else:
               print("Version table not empty, take current version from table.")
               current_version=cursor.fetchone()[0]
               print(current_version)
    
           closeConnection(cursor, connection)
    
           connection = psycopg2.connect(url)
           print ("Zen metastore connection obtained")
           cursor = connection.cursor()
           if current_version<version:
               print("upgrade here")
               for x in range(current_version+1, version+1):
                   cursor.execute(upgrade_sql(x))
               sql="UPDATE DB_VERSION SET version=(%d)" % (version)
               cursor.execute(sql)
           else:
               print("do not upgrade")
        except (Exception, psycopg2.Error) as error :
            print ("Error while connecting to Cockroach DB", error)
            raise Exception('Error executing sql')
            exit(1)
        finally:
            if(connection):
                closeConnection(cursor, connection)
    
    
    if __name__ == "__main__":
        if len (sys.argv) < 4 :
            print("Error : missing one or more arguments")
            print("Usage : python {0} <db_url> <sql_filename> <db_version>".format(sys.argv[0]))
            exit(1)
        else:
            db_url = sys.argv[1]
            sql_file = sys.argv[2]
            version = int(sys.argv[3])
        try:
            current_version=checkIfUpgrade(db_url,version)
            load_db(db_url, sql_file)
            upgrade(db_url, current_version, version)
            exit(0)
        except Exception, err:
            sys.stderr.write('ERROR: %sn' % str(err))
            exit(1)
  create_tables.sql: |-
    CREATE TABLE IF NOT EXISTS DB_VERSION (version INT PRIMARY KEY NOT NULL);
    
    CREATE TABLE  IF NOT EXISTS SERVICE_PROVIDER  (id TEXT PRIMARY KEY NOT NULL, instance_id TEXT NOT NULL, api_key TEXT, state TEXT, metadata jsonb, parameters jsonb,
    serviceInstanceDescription TEXT, serviceInstanceDisplayName TEXT, serviceInstanceNamespace TEXT, transientFields jsonb, zenServiceInstanceInfo jsonb, space_id TEXT, job_def_id TEXT, creation_date TEXT, updation_date TEXT, document_type TEXT, CUSTOMISATION_DEPLOYMENT_REQUEST_ID VARCHAR(256));
    
    CREATE TABLE  IF NOT EXISTS HB_USERS  (id SERIAL PRIMARY KEY NOT NULL, uid TEXT NOT NULL, sID TEXT NOT NULL, role TEXT, username TEXT, password TEXT,
    state TEXT, creation_date TEXT, updation_date TEXT);
    
    CREATE TABLE  IF NOT EXISTS INSTANCE_MANAGER  (
        id SERIAL NOT NULL,
        instance_id TEXT PRIMARY KEY NOT NULL,
        home_volume jsonb,
        api_key TEXT,
        state TEXT,
        account_id TEXT,
        project_id  TEXT,
        creation_date TEXT,
        updation_date TEXT,
        document_type TEXT,
        namespace TEXT,
        deployment_request_id TEXT,
        dataplane_url TEXT,
        cpu_quota INT,
        memory_quota TEXT,
        avail_cpu_quota INT,
        avail_memory_quota TEXT,
        context_type TEXT,
        context_id TEXT,
        job_def_id VARCHAR (512),
        spark_confs jsonb);
    
    CREATE TABLE IF NOT EXISTS dataplane_manager (id TEXT PRIMARY KEY NOT NULL, external_dataplane_url TEXT, internal_dataplane_url TEXT, state TEXT, creation_date TIMESTAMP,
    updation_date TIMESTAMP, document_type TEXT, msg TEXT, tag TEXT, name TEXT, project_id TEXT, nfs jsonb, available_pod_resources jsonb, additional_details jsonb);
    
    CREATE TABLE  IF NOT EXISTS DEPLOY_REQUEST(id TEXT PRIMARY KEY NOT NULL,runtime_id TEXT,state TEXT,document_type TEXT,creation_date TIMESTAMP,updation_date TIMESTAMP, data_plane_uri TEXT,
    deployment_details jsonb);
    
    CREATE TABLE  IF NOT EXISTS DEPLOYMENT(id TEXT PRIMARY KEY NOT NULL, uu_id TEXT, state TEXT,document_type TEXT,creation_date TIMESTAMP,updation_date TIMESTAMP,
    deployment_details jsonb, deployer_type TEXT, deployment_blueprint jsonb, deployment_type TEXT);
    
    CREATE TABLE  IF NOT EXISTS JOB  (
        id SERIAL NOT NULL,
        job_id TEXT PRIMARY KEY NOT NULL,
        instance_id TEXT NOT NULL,
        version TEXT,
        eng jsonb,
        app_args jsonb,
        app_resource TEXT,
        main_class TEXT,
        dataplane_uri TEXT,
        external_dataplane_uri TEXT,
        nfs_home_volume jsonb,
        driver_id TEXT,
        environment TEXT,
        job_state TEXT,
        start_time TIMESTAMP,
        finish_time TIMESTAMP,
        killed_time TIMESTAMP,
        failed_time TIMESTAMP,
        environment_name TEXT,
        runtime_registration_params jsonb,
        register_job_enabled BOOLEAN,
        return_code TEXT,
        mode TEXT,
        user_log_dir TEXT,
        document_type TEXT,
        state TEXT,
        creation_date TIMESTAMP,
        updation_date TIMESTAMP,
        deployment_request_id TEXT,
        project_id TEXT,
        pvc_name TEXT,
        spark_app_id TEXT,
        user_name TEXT,
        resources_updated BOOLEAN,
        context_type TEXT,
        context_id TEXT,
        job_def_id TEXT,
        job_run_id TEXT
        );
    
    CREATE TABLE  IF NOT EXISTS KERNEL (id SERIAL NOT NULL, kernel_id TEXT PRIMARY KEY NOT NULL, instance_id TEXT NOT NULL, name TEXT, external_dataplane_uri TEXT,
    usr_lib_cos jsonb, eng jsonb, jkg_size jsonb, register_kernel_enabled BOOLEAN, env jsonb, nfs_home_volume jsonb, environment TEXT, environment_name TEXT,
    runtime_registration_params jsonb, decommission_time TIMESTAMP, commission_time TIMESTAMP, deletion_time TIMESTAMP, deployment_time TIMESTAMP, document_type TEXT,
    state TEXT, creation_date TIMESTAMP, updation_date TIMESTAMP, cleanup_deployment_request_id TEXT, deployment_request_id  TEXT);
    
    CREATE TABLE IF NOT EXISTS INSTANCE(
         id VARCHAR(36) PRIMARY KEY NOT NULL,
         home_volume VARCHAR (256),
         template_id VARCHAR (256),
         configs TEXT,
         cpu_quota INT,
         memory_quota INT,
         avail_cpu_quota INT,
         avail_memory_quota INT,
         state VARCHAR (32),
         creation_time TIMESTAMPTZ,
         state_change_time TIMESTAMPTZ,
         namespace VARCHAR (32),
         history_server_deployment_request_id VARCHAR (128),
         context_type VARCHAR (32),
         context_id VARCHAR (512),
         job_def_id VARCHAR (512),
         dataplane_type VARCHAR (512),
         dataplane_url VARCHAR (512)
     );
    
      CREATE TABLE IF NOT EXISTS VOLUME_MOUNT (
         id VARCHAR (36) PRIMARY KEY NOT NULL,
         instance_id VARCHAR (36) REFERENCES INSTANCE (id),
         name VARCHAR (256),
         source_sub_path VARCHAR (512),
         mount_path VARCHAR (512)
     );
    
      CREATE TABLE IF NOT EXISTS VOLUME_DEFINITION (
         instance_id VARCHAR(36) REFERENCES INSTANCE (id),
         name VARCHAR (256),
         provider VARCHAR(64),
         type VARCHAR(64),
         details TEXT,
         PRIMARY KEY(instance_id, name)
     );
    
      CREATE TABLE IF NOT EXISTS APPLICATION (
        type VARCHAR(32),
        application_id VARCHAR(36) PRIMARY KEY NOT NULL,
        instance_id VARCHAR(36),
        application_details TEXT,
        environment VARCHAR(36),
        state VARCHAR(36),
        start_time TIMESTAMPTZ,
        finish_time TIMESTAMPTZ,
        failed_time TIMESTAMPTZ,
        additional_attributes TEXT,
        return_code VARCHAR(36),
        mode VARCHAR(36)
        );
    
     
      CREATE TABLE IF NOT EXISTS APPLICATION_VOLUME_MAP (
        application_id VARCHAR(36),
        instance_id VARCHAR(36),
        name VARCHAR(256),
        source_sub_path VARCHAR(512),
        mount_path VARCHAR(512),
        mode VARCHAR(36)
        );
    
     
      CREATE TABLE IF NOT EXISTS RUNTIME (
        application_id VARCHAR(36),
        template_id VARCHAR(128),
        master_memory BIGINT,
        master_cores INT,
        worker_memory BIGINT,
        worker_cores INT,
        num_workers_running INT,
        num_workers_requested INT,
        creation_time TIMESTAMPTZ,
        state_change_time TIMESTAMPTZ,
        updation_time TIMESTAMPTZ,
        state VARCHAR(36),
        deployment_request_id VARCHAR(36),
        dataplane_uri VARCHAR(256),
        external_dataplane_uri VARCHAR(256)
        );
    
      CREATE TABLE IF NOT EXISTS APPLICATION_REQUEST_RESPONSE_TRACKER (
        application_id VARCHAR(36),
        instance_id VARCHAR(36),
        request_type VARCHAR(36),
        requested_time TIMESTAMPTZ,
        response_code INT,
        response_message VARCHAR(128)
        );
{% endif %}
